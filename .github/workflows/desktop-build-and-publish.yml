name: Desktop - Build and publish electron app

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to build (e.g., 1.0.0). Leave empty to use package.json'
        required: false
        default: ''
        type: string
      build_type:
        description: 'Type of build to run'
        required: true
        default: 'linux'
        type: choice
        options:
          - linux
          - windows
          - macos
          - all

jobs:
  build-windows:
    runs-on: windows-latest
    if: |
      github.event_name == 'push' ||
      (github.event_name == 'workflow_dispatch' && 
       (github.event.inputs.build_type == 'windows' || github.event.inputs.build_type == 'all'))

    steps:
      - name: Check out Git repository
        uses: actions/checkout@v3
        with:
          ref: ${{ github.event_name == 'workflow_dispatch' && 'linux-build' || github.ref }}
          fetch-depth: 1

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: 22
          cache: 'npm'

      - name: Cache Electron (Windows)
        uses: actions/cache@v3
        with:
          path: |
            ~\AppData\Local\electron\Cache
            ~\AppData\Local\electron-builder\Cache
          key: ${{ runner.os }}-electron-cache-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-electron-cache-

      - name: Extract version from tag or input
        shell: pwsh
        run: |
          if ("${{ github.event_name }}" -eq "workflow_dispatch" -and -not [string]::IsNullOrEmpty("${{ github.event.inputs.version }}")) {
            $env:VERSION = "${{ github.event.inputs.version }}"
          } elseif ("${{ github.ref }}" -like "refs/tags/*") {
            $env:VERSION = "${{ github.ref }}" -replace '^refs/tags/v',''
          } else {
            # Fallback: read version from apps/desktop/package.json
            $pkgPath = "apps/desktop/package.json"
            $pkg = Get-Content $pkgPath -Raw | ConvertFrom-Json
            $env:VERSION = $pkg.version
          }
          echo "VERSION=$env:VERSION" >> $env:GITHUB_ENV

      - name: Set version and commit SHA into build.ts
        shell: pwsh
        run: |
          $content = @'
          // This file is auto-generated during CI/CD
          const VERSION = "${{ env.VERSION }}";
          const SHA = "${{ github.sha }}";

          export const build = {
              version: VERSION,
              sha: SHA
          };
          '@
          Set-Content -Path "./packages/core/src/types/build.ts" -Value $content

      - name: Check Windows Certificate Status
        shell: pwsh
        run: |
          Write-Host "🔍 Checking Windows certificate configuration..."
          
          if ([string]::IsNullOrEmpty("${{ secrets.WINDOWS_CERT_BASE64 }}") -or [string]::IsNullOrEmpty("${{ secrets.WINDOWS_CERT_PASSWORD }}")) {
            Write-Host "⚠️  Warning: Windows certificate secrets are not configured"
            Write-Host "📝 Building without code signing (packages will be unsigned)"
            Write-Host "💡 To enable code signing, set these secrets:"
            Write-Host "   - WINDOWS_CERT_BASE64: Your .pfx certificate file encoded in base64"
            Write-Host "   - WINDOWS_CERT_PASSWORD: The password for your certificate"
            Write-Host "✅ Continuing with unsigned build..."
            Write-Host "🔧 Setting SIGNING_ENABLED=false to disable code signing in Electron Forge"
            
            # Set empty values to avoid errors in subsequent steps
            echo "CERTIFICATE_PATH=" >> $env:GITHUB_ENV
            echo "SIGNING_ENABLED=false" >> $env:GITHUB_ENV
          } else {
            Write-Host "✅ Windows certificate secrets are configured"
            Write-Host "🔐 Proceeding with code signing..."
            Write-Host "🔧 Setting SIGNING_ENABLED=true to enable code signing in Electron Forge"
            echo "SIGNING_ENABLED=true" >> $env:GITHUB_ENV
          }
          
          Write-Host "📋 Environment variable SIGNING_ENABLED=${{ env.SIGNING_ENABLED }}"

      - name: Decode certificate
        if: env.SIGNING_ENABLED == 'true'
        shell: pwsh
        run: |
          Write-Host "🔐 Setting up code signing environment..."
          
          # Check if the secret exists and has content
          if ([string]::IsNullOrEmpty("${{ secrets.WINDOWS_CERT_BASE64 }}")) {
            Write-Host "❌ Error: WINDOWS_CERT_BASE64 secret is empty or not set"
            exit 1
          }
          
          $certPath = Join-Path -Path $env:RUNNER_TEMP -ChildPath "build_cert.pfx"
          $certContent = [System.Convert]::FromBase64String($env:WINDOWS_CERT_BASE64)
          [IO.File]::WriteAllBytes($certPath, $certContent)
          echo "CERTIFICATE_PATH=$certPath" >> $env:GITHUB_ENV
          
          Write-Host "✅ Certificate file created successfully"
          Get-ChildItem $certPath | Format-List

      - name: Update package.json version
        shell: bash
        working-directory: apps/desktop
        run: |
          # Update version without triggering npm hooks
          node -e "
            const fs = require('fs');
            const pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'));
            pkg.version = '${{ env.VERSION }}';
            fs.writeFileSync('package.json', JSON.stringify(pkg, null, 2));
          "

      - name: Install Root Dependencies
        run: npm install

      - name: Install Dependencies
        working-directory: apps/desktop
        run: npm install

      - name: Build Electron App (Windows x64)
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          CERTIFICATE_PATH: ${{ env.CERTIFICATE_PATH }}
          CERTIFICATE_PASSWORD: ${{ secrets.WINDOWS_CERT_PASSWORD }}
          NODE_ENV: production
          SIGNING_ENABLED: ${{ env.SIGNING_ENABLED }}
        working-directory: apps/desktop
        shell: pwsh
        run: |
          if ("${{ env.SIGNING_ENABLED }}" -eq "true") {
            Write-Host "🔐 Building with code signing (x64)..."
            npm run make -- --platform=win32 --arch=x64
          } else {
            Write-Host "📝 Building without code signing (x64)..."
            Write-Host "🚫 Disabling code signing for unsigned build..."
            # Set environment variables to disable code signing
            $env:CSC_IDENTITY_AUTO_DISCOVERY = "false"
            $env:CSC_LINK = ""
            $env:CSC_KEY_PASSWORD = ""
            npm run make -- --platform=win32 --arch=x64
          }

      - name: Build Electron App (Windows ARM64)
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          CERTIFICATE_PATH: ${{ env.CERTIFICATE_PATH }}
          CERTIFICATE_PASSWORD: ${{ secrets.WINDOWS_CERT_PASSWORD }}
          NODE_ENV: production
          SIGNING_ENABLED: ${{ env.SIGNING_ENABLED }}
        working-directory: apps/desktop
        shell: pwsh
        run: |
          if ("${{ env.SIGNING_ENABLED }}" -eq "true") {
            Write-Host "🔐 Building with code signing (ARM64)..."
            npm run make -- --platform=win32 --arch=arm64
          } else {
            Write-Host "📝 Building without code signing (ARM64)..."
            Write-Host "🚫 Disabling code signing for unsigned build..."
            # Set environment variables to disable code signing
            $env:CSC_IDENTITY_AUTO_DISCOVERY = "false"
            $env:CSC_LINK = ""
            $env:CSC_KEY_PASSWORD = ""
            npm run make -- --platform=win32 --arch=arm64
          }

      - name: Debug Windows Build Output
        working-directory: apps/desktop
        shell: pwsh
        run: |
          Write-Host "=== Windows Build Output Directory Structure ==="
          Write-Host "=== Full out/ directory contents ==="
          if (Test-Path "out/") {
            Get-ChildItem -Recurse "out/" | Format-Table -AutoSize
          } else {
            Write-Host "out/ directory not found"
          }
          Write-Host "=== Looking for Windows packages ==="
          $packages = Get-ChildItem -Recurse "out/" -Include "*.exe", "*.msi", "*.zip" -ErrorAction SilentlyContinue
          if ($packages) {
            $packages | ForEach-Object { Write-Host "Found: $($_.FullName)" }
          } else {
            Write-Host "No Windows packages found"
          }

      - name: Publish Electron App (Windows)
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          NODE_ENV: production
        working-directory: apps/desktop
        continue-on-error: true
        shell: pwsh
        run: |
          Write-Host "🚀 Attempting to publish to GitHub releases..."
          Write-Host "📝 Note: Publishing requires GitHub repository permissions"
          Write-Host "🔧 If publish fails, packages are still available as artifacts"
          
          # Try to publish, but don't fail the build if it doesn't work
          $ErrorActionPreference = "Continue"
          npm run publish 2>&1
          $PUBLISH_EXIT_CODE = $LASTEXITCODE
          
          if ($PUBLISH_EXIT_CODE -ne 0) {
            Write-Host "⚠️  Publish failed, but build succeeded!"
            Write-Host "📦 Your Windows packages are available as artifacts above"
            Write-Host "🔍 Publish error details saved above"
            Write-Host "💡 To fix publish issues, check:"
            Write-Host "   1. GitHub repository settings → Actions → General"
            Write-Host "   2. Ensure 'Read and write permissions' is enabled"
            Write-Host "   3. Ensure 'Allow GitHub Actions to create and approve pull requests' is enabled"
            Write-Host "✅ Build completed successfully despite publish failure"
          } else {
            Write-Host "✅ Publish completed successfully!"
          }
          
          # Always exit with success to continue the workflow
          exit 0

      - name: Upload Windows x64 EXE
        uses: actions/upload-artifact@v4
        with:
          name: Colanode-${{ env.VERSION }}-windows-x64.exe
          path: apps/desktop/out/make/**/x64/*.exe
          retention-days: 30

      - name: Upload Windows x64 MSI
        uses: actions/upload-artifact@v4
        with:
          name: Colanode-${{ env.VERSION }}-windows-x64.msi
          path: apps/desktop/out/make/**/x64/*.msi
          retention-days: 30

      - name: Upload Windows x64 ZIP
        uses: actions/upload-artifact@v4
        with:
          name: Colanode-${{ env.VERSION }}-windows-x64.zip
          path: apps/desktop/out/make/zip/win32/x64/*.zip
          retention-days: 30

      - name: Upload Windows ARM64 EXE
        uses: actions/upload-artifact@v4
        with:
          name: Colanode-${{ env.VERSION }}-windows-arm64.exe
          path: apps/desktop/out/make/**/arm64/*.exe
          retention-days: 30

      - name: Upload Windows ARM64 MSI
        uses: actions/upload-artifact@v4
        with:
          name: Colanode-${{ env.VERSION }}-windows-arm64.msi
          path: apps/desktop/out/make/**/arm64/*.msi
          retention-days: 30

      - name: Upload Windows ARM64 ZIP
        uses: actions/upload-artifact@v4
        with:
          name: Colanode-${{ env.VERSION }}-windows-arm64.zip
          path: apps/desktop/out/make/zip/win32/arm64/*.zip
          retention-days: 30

      - name: Clean up certificate
        if: always() && env.SIGNING_ENABLED == 'true'
        shell: pwsh
        run: |
          if (Test-Path $env:CERTIFICATE_PATH) {
            Remove-Item -Path $env:CERTIFICATE_PATH -Force
            Write-Host "✅ Certificate cleaned up successfully"
          } else {
            Write-Host "ℹ️  No certificate to clean up"
          }

  build-macos:
    runs-on: macos-latest
    if: |
      github.event_name == 'push' ||
      (github.event_name == 'workflow_dispatch' && 
       (github.event.inputs.build_type == 'macos' || github.event.inputs.build_type == 'all'))

    steps:
      - name: Check out Git repository
        uses: actions/checkout@v3
        with:
          ref: ${{ github.event_name == 'workflow_dispatch' && 'linux-build' || github.ref }}
          fetch-depth: 1

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: 22
          cache: 'npm'

      - name: Cache Electron (macOS)
        uses: actions/cache@v3
        with:
          path: |
            ~/Library/Caches/electron
            ~/Library/Caches/electron-builder
          key: ${{ runner.os }}-electron-cache-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-electron-cache-

      - name: Extract version from tag or input
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" && -n "${{ github.event.inputs.version }}" ]]; then
            echo "VERSION=${{ github.event.inputs.version }}" >> $GITHUB_ENV
          elif [[ "${{ github.ref }}" == refs/tags/* ]]; then
            echo "VERSION=${GITHUB_REF#refs/tags/v}" >> $GITHUB_ENV
          else
            # Fallback: read version from apps/desktop/package.json
            VERSION=$(node -e "console.log(require('./apps/desktop/package.json').version)")
            echo "VERSION=$VERSION" >> $GITHUB_ENV
          fi

      - name: Set version and commit SHA into build.ts
        run: |
          cat <<EOF > ./packages/core/src/types/build.ts
          // This file is auto-generated during CI/CD
          const VERSION = "${{ env.VERSION }}";
          const SHA = "${{ github.sha }}";

          export const build = {
              version: VERSION,
              sha: SHA
          };
          EOF

      - name: Check macOS Certificate Status
        run: |
          echo "🔍 Checking macOS certificate configuration..."
          
          if [ -z "${{ secrets.MACOS_CERTIFICATE_BASE64 }}" ] || [ -z "${{ secrets.MACOS_CERTIFICATE_PASSWORD }}" ]; then
            echo "⚠️  Warning: macOS certificate secrets are not configured"
            echo "📝 Building without code signing (packages will be unsigned)"
            echo "💡 To enable code signing, set these secrets:"
            echo "   - MACOS_CERTIFICATE_BASE64: Your .p12 certificate file encoded in base64"
            echo "   - MACOS_CERTIFICATE_PASSWORD: The password for your certificate"
            echo "✅ Continuing with unsigned build..."
            echo "🔧 Setting SIGNING_ENABLED=false to disable code signing in Electron Forge"
            
            # Set empty values to avoid errors in subsequent steps
            echo "KEYCHAIN_PATH=" >> $GITHUB_ENV
            echo "KEYCHAIN_PASSWORD=" >> $GITHUB_ENV
            echo "SIGNING_ENABLED=false" >> $GITHUB_ENV
          else
            echo "✅ macOS certificate secrets are configured"
            echo "🔐 Proceeding with code signing..."
            echo "🔧 Setting SIGNING_ENABLED=true to enable code signing in Electron Forge"
            echo "SIGNING_ENABLED=true" >> $GITHUB_ENV
          fi
          
          echo "📋 Environment variable SIGNING_ENABLED=${{ env.SIGNING_ENABLED }}"
        shell: bash

      - name: Decode and Import macOS Certificate
        if: env.SIGNING_ENABLED == 'true'
        run: |
          echo "🔐 Setting up code signing environment..."
          
          # Check if the secret exists and has content
          if [ -z "${{ secrets.MACOS_CERTIFICATE_BASE64 }}" ]; then
            echo "❌ Error: MACOS_CERTIFICATE_BASE64 secret is empty or not set"
            exit 1
          fi
          
          echo "🔍 Certificate secret length: ${#MACOS_CERTIFICATE_BASE64}"
          
          # Decode the base64 encoded certificate
          echo "${{ secrets.MACOS_CERTIFICATE_BASE64 }}" | base64 --decode > "${RUNNER_TEMP}/certificate.p12"
          
          # Verify the certificate file exists and has content
          if [ ! -s "${RUNNER_TEMP}/certificate.p12" ]; then
            echo "❌ Error: Certificate file is empty or was not created properly"
            echo "🔍 Certificate file size: $(wc -c < "${RUNNER_TEMP}/certificate.p12" 2>/dev/null || echo 'unknown')"
            echo "🔍 Certificate file exists: $(test -f "${RUNNER_TEMP}/certificate.p12" && echo 'yes' || echo 'no')"
            echo "🔍 Certificate file readable: $(test -r "${RUNNER_TEMP}/certificate.p12" && echo 'yes' || echo 'no')"
            exit 1
          fi
          
          echo "✅ Certificate file created successfully"
          ls -la "${RUNNER_TEMP}/certificate.p12"
          echo "🔍 Certificate file type:"
          file "${RUNNER_TEMP}/certificate.p12" || echo "file command not available"

          # Create a temporary keychain
          KEYCHAIN_PATH="${RUNNER_TEMP}/temporary.keychain"
          echo "🔐 Creating temporary keychain..."
          security create-keychain -p "${{ secrets.MACOS_CERTIFICATE_PASSWORD }}" "${KEYCHAIN_PATH}"
          
          if [ $? -ne 0 ]; then
            echo "❌ Error: Failed to create keychain"
            echo "🔍 Keychain creation failed. Checking security command availability..."
            which security || echo "security command not found"
            exit 1
          fi
          echo "✅ Keychain created successfully"

          # Import the certificate into the temporary keychain
          echo "🔐 Importing certificate into keychain..."
          security import "${RUNNER_TEMP}/certificate.p12" -k "${KEYCHAIN_PATH}" -P "${{ secrets.MACOS_CERTIFICATE_PASSWORD }}" -T /usr/bin/codesign
          
          if [ $? -ne 0 ]; then
            echo "❌ Error: Failed to import certificate"
            echo "🔍 Certificate file info:"
            file "${RUNNER_TEMP}/certificate.p12"
            echo "🔍 Keychain info:"
            security list-keychains
            echo "🔍 Available keychains:"
            security list-keychains -d user
            exit 1
          fi
          echo "✅ Certificate imported successfully"

          # Set the temporary keychain as the default keychain
          security default-keychain -s "${KEYCHAIN_PATH}"
          echo "✅ Keychain set as default"

          # Unlock the keychain
          security unlock-keychain -p "${{ secrets.MACOS_CERTIFICATE_PASSWORD }}" "${KEYCHAIN_PATH}"
          echo "✅ Keychain unlocked"

          # List available keys to verify (for debugging)
          echo "🔍 Available signing identities:"
          security find-identity -v -p codesigning "${KEYCHAIN_PATH}"

          # Set environment variables for codesigning
          echo "KEYCHAIN_PATH=${KEYCHAIN_PATH}" >> $GITHUB_ENV
          echo "KEYCHAIN_PASSWORD=${{ secrets.MACOS_CERTIFICATE_PASSWORD }}" >> $GITHUB_ENV
          echo "✅ Environment variables set"
        shell: bash

      - name: Update package.json version
        working-directory: apps/desktop
        run: |
          # Update version without triggering npm hooks
          node -e "
            const fs = require('fs');
            const pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'));
            pkg.version = '${{ env.VERSION }}';
            fs.writeFileSync('package.json', JSON.stringify(pkg, null, 2));
          "

      - name: Install Root Dependencies
        run: npm install

      - name: Install Dependencies
        working-directory: apps/desktop
        run: npm install

      - name: Build Electron App (macOS Apple Silicon)
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          NODE_ENV: production
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_ID_PASSWORD: ${{ secrets.APPLE_ID_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
          KEYCHAIN_PATH: ${{ env.KEYCHAIN_PATH }}
          KEYCHAIN_PASSWORD: ${{ env.KEYCHAIN_PASSWORD }}
          SIGNING_ENABLED: ${{ env.SIGNING_ENABLED }}
        working-directory: apps/desktop
        run: |
          if [ "${{ env.SIGNING_ENABLED }}" = "true" ]; then
            echo "🔐 Building with code signing..."
            npm run make -- --platform=darwin --arch="arm64"
          else
            echo "📝 Building without code signing..."
            echo "🚫 Disabling code signing for unsigned build..."
            # Set environment variables to disable code signing
            export CSC_IDENTITY_AUTO_DISCOVERY=false
            export CSC_LINK=
            export CSC_KEY_PASSWORD=
            npm run make -- --platform=darwin --arch="arm64"
          fi

      - name: Build Electron App (macOS Intel)
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          NODE_ENV: production
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_ID_PASSWORD: ${{ secrets.APPLE_ID_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
          KEYCHAIN_PATH: ${{ env.KEYCHAIN_PATH }}
          KEYCHAIN_PASSWORD: ${{ env.KEYCHAIN_PASSWORD }}
          SIGNING_ENABLED: ${{ env.SIGNING_ENABLED }}
        working-directory: apps/desktop
        run: |
          if [ "${{ env.SIGNING_ENABLED }}" = "true" ]; then
            echo "🔐 Building with code signing..."
            npm run make -- --platform=darwin --arch="x64"
          else
            echo "📝 Building without code signing..."
            echo "🚫 Disabling code signing for unsigned build..."
            # Set environment variables to disable code signing
            export CSC_IDENTITY_AUTO_DISCOVERY=false
            export CSC_LINK=
            export CSC_KEY_PASSWORD=
            npm run make -- --platform=darwin --arch="x64"
          fi

      - name: Debug macOS Build Output
        working-directory: apps/desktop
        run: |
          echo "=== macOS Build Output Directory Structure ==="
          echo "=== Full out/ directory contents ==="
          ls -la out/ || echo "out/ directory not found"
          echo "=== Looking for macOS packages ==="
          find out/ -name "*.dmg" -o -name "*.zip" 2>/dev/null || echo "No macOS packages found"

      - name: Publish Electron App (macOS)
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          NODE_ENV: production
        working-directory: apps/desktop
        continue-on-error: true
        run: |
          echo "🚀 Attempting to publish to GitHub releases..."
          echo "📝 Note: Publishing requires GitHub repository permissions"
          echo "🔧 If publish fails, packages are still available as artifacts"
          
          # Try to publish, but don't fail the build if it doesn't work
          set +e  # Don't exit on error
          npm run publish 2>&1
          PUBLISH_EXIT_CODE=$?
          
          if [ $PUBLISH_EXIT_CODE -ne 0 ]; then
            echo "⚠️  Publish failed, but build succeeded!"
            echo "📦 Your macOS packages are available as artifacts above"
            echo "🔍 Publish error details saved above"
            echo "💡 To fix publish issues, check:"
            echo "   1. GitHub repository settings → Actions → General"
            echo "   2. Ensure 'Read and write permissions' is enabled"
            echo "   3. Ensure 'Allow GitHub Actions to create and approve pull requests' is enabled"
            echo "✅ Build completed successfully despite publish failure"
          else
            echo "✅ Publish completed successfully!"
          fi
          
          # Always exit with success to continue the workflow
          exit 0

      - name: Upload macOS Apple Silicon DMG
        uses: actions/upload-artifact@v4
        with:
          name: Colanode-${{ env.VERSION }}-darwin-arm64.dmg
          path: apps/desktop/out/**/*arm64*.dmg
          retention-days: 30

      - name: Upload macOS Intel DMG
        uses: actions/upload-artifact@v4
        with:
          name: Colanode-${{ env.VERSION }}-darwin-x64.dmg
          path: apps/desktop/out/**/*x64*.dmg
          retention-days: 30

      - name: Upload macOS ZIP
        uses: actions/upload-artifact@v4
        with:
          name: Colanode-${{ env.VERSION }}-darwin-x64.zip
          path: apps/desktop/out/**/*.zip
          retention-days: 30

      - name: Delete Temporary Keychain
        if: always() && env.SIGNING_ENABLED == 'true'
        run: |
          echo "🧹 Cleaning up temporary keychain..."
          if [ -n "${{ env.KEYCHAIN_PATH }}" ] && [ -f "${{ env.KEYCHAIN_PATH }}" ]; then
            echo "🔍 Attempting to delete keychain: ${{ env.KEYCHAIN_PATH }}"
            security delete-keychain "${{ env.KEYCHAIN_PATH }}" 2>/dev/null || {
              echo "⚠️  Warning: Could not delete keychain (this is normal if build failed early)"
              echo "🔍 Keychain cleanup will happen automatically when runner is recycled"
            }
          else
            echo "ℹ️  No keychain to clean up"
          fi
          echo "✅ Cleanup completed"
        shell: bash

  build-linux:
    runs-on: ubuntu-latest
    if: |
      github.event_name == 'push' ||
      (github.event_name == 'workflow_dispatch' && 
       (github.event.inputs.build_type == 'linux' || github.event.inputs.build_type == 'all'))

    steps:
      - name: Check out Git repository
        uses: actions/checkout@v3
        with:
          ref: ${{ github.event_name == 'workflow_dispatch' && 'linux-build' || github.ref }}
          fetch-depth: 1

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: 22
          cache: 'npm'

      - name: Cache Electron (Linux)
        uses: actions/cache@v3
        with:
          path: |
            ~/.cache/electron
            ~/.cache/electron-builder
          key: ${{ runner.os }}-electron-cache-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-electron-cache-

      - name: Extract version from tag or input
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" && -n "${{ github.event.inputs.version }}" ]]; then
            echo "VERSION=${{ github.event.inputs.version }}" >> $GITHUB_ENV
          elif [[ "${{ github.ref }}" == refs/tags/* ]]; then
            echo "VERSION=${GITHUB_REF#refs/tags/v}" >> $GITHUB_ENV
          else
            # Fallback: read version from apps/desktop/package.json
            echo "VERSION=0.3.4" >> $GITHUB_ENV
          fi

      - name: Set version and commit SHA into build.ts
        run: |
          cat <<EOF > ./packages/core/src/types/build.ts
          // This file is auto-generated during CI/CD
          const VERSION = "${{ env.VERSION }}";
          const SHA = "${{ github.sha }}";

          export const build = {
              version: VERSION,
              sha: SHA
          };
          EOF

      - name: Update package.json version
        working-directory: apps/desktop
        run: |
          # Update version without triggering npm hooks
          node -e "
            const fs = require('fs');
            const pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'));
            pkg.version = '${{ env.VERSION }}';
            fs.writeFileSync('package.json', JSON.stringify(pkg, null, 2));
          "

      - name: Install Root Dependencies
        run: npm install

      - name: Install Dependencies
        working-directory: apps/desktop
        run: npm install

      - name: Build Electron App (Linux)
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          NODE_ENV: production
        working-directory: apps/desktop
        run: npm run make -- --platform=linux

      - name: Debug Build Output
        working-directory: apps/desktop
        run: |
          echo "=== Build Output Directory Structure ==="
          find out/ -type f -name "colanode*" 2>/dev/null || echo "No colanode files found"
          echo "=== Full out/ directory contents ==="
          ls -la out/ || echo "out/ directory not found"
          echo "=== Looking for DEB and RPM packages ==="
          find out/ -name "*.deb" -o -name "*.rpm" 2>/dev/null || echo "No DEB or RPM packages found"
          echo "=== Looking for ZIP packages ==="
          find out/ -name "*.zip" 2>/dev/null || echo "No ZIP packages found"
          echo "=== Package.json contents ==="
          cat package.json | grep -E "(name|version|executableName)"
          echo "=== Forge config name ==="
          echo "Expected name: colanode"
          echo "=== Looking for executable ==="
          find out/ -name "colanode" -type f 2>/dev/null || echo "Executable 'colanode' not found"
          echo "=== Expected binary path ==="
          echo "Should be: out/colanode-linux-x64/colanode"

      - name: Publish Electron App
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          NODE_ENV: production
        working-directory: apps/desktop
        continue-on-error: true
        run: |
          echo "🚀 Attempting to publish to GitHub releases..."
          echo "📝 Note: Publishing requires GitHub repository permissions"
          echo "🔧 If publish fails, packages are still available as artifacts"
          
          # Try to publish, but don't fail the build if it doesn't work
          set +e  # Don't exit on error
          npm run publish 2>&1
          PUBLISH_EXIT_CODE=$?
          
          if [ $PUBLISH_EXIT_CODE -ne 0 ]; then
            echo "⚠️  Publish failed, but build succeeded!"
            echo "📦 Your Linux packages are available as artifacts above"
            echo "🔍 Publish error details saved above"
            echo "💡 To fix publish issues, check:"
            echo "   1. GitHub repository settings → Actions → General"
            echo "   2. Ensure 'Read and write permissions' is enabled"
            echo "   3. Ensure 'Allow GitHub Actions to create and approve pull requests' is enabled"
            echo "✅ Build completed successfully despite publish failure"
          else
            echo "✅ Publish completed successfully!"
          fi
          
          # Always exit with success to continue the workflow
          exit 0

      - name: Upload DEB Package
        uses: actions/upload-artifact@v4
        with:
          name: Colanode-${{ env.VERSION }}-amd64.deb
          path: apps/desktop/out/**/*.deb
          retention-days: 30

      - name: Upload RPM Package
        uses: actions/upload-artifact@v4
        with:
          name: Colanode-${{ env.VERSION }}-amd64.rpm
          path: apps/desktop/out/**/*.rpm
          retention-days: 30

      - name: Upload Linux ZIP Package
        uses: actions/upload-artifact@v4
        with:
          name: Colanode-${{ env.VERSION }}-linux-x64.zip
          path: apps/desktop/out/**/*.zip
          retention-days: 30
        continue-on-error: true
